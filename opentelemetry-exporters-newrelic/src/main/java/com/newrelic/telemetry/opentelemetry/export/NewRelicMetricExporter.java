/*
 * Copyright 2020 New Relic Corporation. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

package com.newrelic.telemetry.opentelemetry.export;

import static com.newrelic.telemetry.opentelemetry.export.AttributeNames.COLLECTOR_NAME;
import static com.newrelic.telemetry.opentelemetry.export.AttributeNames.DESCRIPTOR_DESCRIPTION;
import static com.newrelic.telemetry.opentelemetry.export.AttributeNames.DESCRIPTOR_UNIT;
import static com.newrelic.telemetry.opentelemetry.export.AttributeNames.INSTRUMENTATION_PROVIDER;
import static com.newrelic.telemetry.opentelemetry.export.AttributeNames.SERVICE_INSTANCE_ID;

import com.newrelic.telemetry.Attributes;
import com.newrelic.telemetry.MetricBatchSenderFactory;
import com.newrelic.telemetry.OkHttpPoster;
import com.newrelic.telemetry.SenderConfiguration;
import com.newrelic.telemetry.TelemetryClient;
import com.newrelic.telemetry.metrics.Metric;
import com.newrelic.telemetry.metrics.MetricBatchSender;
import com.newrelic.telemetry.metrics.MetricBuffer;
import io.opentelemetry.sdk.internal.MillisClock;
import io.opentelemetry.sdk.metrics.data.MetricData;
import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;
import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor.Type;
import io.opentelemetry.sdk.metrics.data.MetricData.Point;
import io.opentelemetry.sdk.metrics.export.MetricExporter;
import java.net.MalformedURLException;
import java.net.URI;
import java.util.Collection;

/**
 * The NewRelicMetricExporter takes a collection of MetricData objects, converts them into a New
 * Relic MetricBatch instance and then sends it to the New Relic metric ingest API via a
 * TelemetryClient.
 *
 * <p>This is a "push-based" exporter, and so will need to be hooked up with a {@link
 * io.opentelemetry.sdk.metrics.export.IntervalMetricReader} in order
 *
 * @since 0.3.0
 */
public class NewRelicMetricExporter implements MetricExporter {

  private final Attributes commonAttributes;
  private final TelemetryClient telemetryClient;
  private final TimeTracker timeTracker;
  private final MetricPointAdapter metricPointAdapter;

  /**
   * Create a metric exporter with the given components.
   *
   * @param telemetryClient A {@link TelemetryClient} instance
   * @param serviceAttributes A set of attributes to be appended to all metrics generated by this
   *     exporter.
   * @param timeTracker A {@link TimeTracker} used to compute delta values from cumulative values,
   *     where necessary.
   * @param metricPointAdapter The {@link MetricPointAdapter} that converts OpenTelemetry Point
   *     instances into New Relic {@link Metric}s.
   * @param serviceInstanceId The unique identifier for the instance of the service that this is
   *     reporting telemetry for. This will be overridden by the same attribute in the OTel
   *     Resource, if it is there.
   */
  NewRelicMetricExporter(
      TelemetryClient telemetryClient,
      Attributes serviceAttributes,
      TimeTracker timeTracker,
      MetricPointAdapter metricPointAdapter,
      String serviceInstanceId) {
    this.telemetryClient = telemetryClient;
    this.timeTracker = timeTracker;
    // todo: these two attributes are the same as the ones in the SpanBatchAdapter. Move to
    // somewhere common.
    this.commonAttributes =
        serviceAttributes
            .copy()
            .put(INSTRUMENTATION_PROVIDER, "opentelemetry")
            .put(COLLECTOR_NAME, "newrelic-opentelemetry-exporter")
            .put(SERVICE_INSTANCE_ID, serviceInstanceId);
    this.metricPointAdapter = metricPointAdapter;
  }

  /**
   * Create a new {@link Builder}.
   *
   * @return A {@link Builder} with defaults pre-set.
   */
  public static Builder newBuilder() {
    return new Builder();
  }

  @Override
  public ResultCode export(Collection<MetricData> metrics) {
    MetricBuffer buffer = MetricBuffer.builder().attributes(commonAttributes).build();
    for (MetricData metric : metrics) {
      Descriptor descriptor = metric.getDescriptor();
      Type type = descriptor.getType();

      Attributes attributes = buildCommonAttributes(metric);

      Collection<Point> points = metric.getPoints();
      for (Point point : points) {
        Collection<Metric> metricsFromPoint =
            metricPointAdapter.buildMetricsFromPoint(descriptor, type, attributes.copy(), point);
        metricsFromPoint.forEach(buffer::addMetric);
      }
    }
    timeTracker.tick();
    telemetryClient.sendBatch(buffer.createBatch());
    return ResultCode.SUCCESS;
  }

  @Override
  public ResultCode flush() {
    // no-op for this exporter
    return ResultCode.SUCCESS;
  }

  @Override
  public void shutdown() {
    telemetryClient.shutdown();
  }

  private Attributes buildCommonAttributes(MetricData metric) {
    Attributes attributes = new Attributes();
    AttributesSupport.addResourceAttributes(attributes, metric.getResource());
    AttributesSupport.populateLibraryInfo(attributes, metric.getInstrumentationLibraryInfo());

    Descriptor descriptor = metric.getDescriptor();
    attributes.put(DESCRIPTOR_DESCRIPTION, descriptor.getDescription());
    attributes.put(DESCRIPTOR_UNIT, descriptor.getUnit());
    descriptor.getConstantLabels().forEach(attributes::put);
    return attributes;
  }

  /**
   * Builder utility for this exporter. At the very minimum, you need to provide your New Relic
   * Insert API Key for this to work.
   *
   * @since 0.1.0
   */
  public static class Builder {

    private Attributes commonAttributes = new Attributes();
    private TelemetryClient telemetryClient;
    private String apiKey;
    private boolean enableAuditLogging = false;
    private URI uriOverride;

    /**
     * A TelemetryClient from the New Relic Telemetry SDK. This allows you to provide your own
     * custom-built MetricBatchSender (for instance, if you need to enable proxies, etc).
     *
     * @param telemetryClient the sender to use.
     * @return this builder's instance
     */
    public NewRelicMetricExporter.Builder telemetryClient(TelemetryClient telemetryClient) {
      this.telemetryClient = telemetryClient;
      return this;
    }

    /**
     * Set your New Relic Insert Key.
     *
     * @param apiKey your New Relic Insert Key.
     * @return this builder's instance
     */
    public NewRelicMetricExporter.Builder apiKey(String apiKey) {
      this.apiKey = apiKey;
      return this;
    }

    /**
     * Turn on Audit Logging for the New Relic Telemetry SDK. This will provide additional logging
     * of the data being sent to the New Relic Trace API at DEBUG logging level.
     *
     * <p>WARNING: If there is sensitive data in your Traces, this will cause that data to be
     * exposed to wherever your logs are being sent.
     *
     * @return this builder's instance
     */
    public NewRelicMetricExporter.Builder enableAuditLogging() {
      enableAuditLogging = true;
      return this;
    }

    /**
     * A set of attributes that should be attached to all Metrics that are sent to New Relic.
     *
     * @param commonAttributes the attributes to attach
     * @return this builder's instance
     */
    public NewRelicMetricExporter.Builder commonAttributes(Attributes commonAttributes) {
      this.commonAttributes = commonAttributes;
      return this;
    }

    /**
     * Set a URI to override the default metric ingest endpoint. If this is not provided, the
     * telemetry SDK will choose the US production endpoint as a default.
     *
     * @param uriOverride - The fully qualified URI endpoint for the metric ingest api.
     * @return the Builder
     */
    public NewRelicMetricExporter.Builder uriOverride(URI uriOverride) {
      this.uriOverride = uriOverride;
      return this;
    }

    /**
     * Constructs a new instance of the exporter based on the builder's values.
     *
     * @return a new {@link NewRelicMetricExporter} instance
     */
    public NewRelicMetricExporter build() {
      TimeTracker timeTracker = new TimeTracker(MillisClock.getInstance());
      if (telemetryClient != null) {
        return new NewRelicMetricExporter(
            telemetryClient,
            commonAttributes,
            timeTracker,
            new MetricPointAdapter(timeTracker),
            AttributesSupport.SERVICE_INSTANCE_ID);
      }
      SenderConfiguration.SenderConfigurationBuilder builder =
          MetricBatchSenderFactory.fromHttpImplementation(OkHttpPoster::new)
              .configureWith(apiKey)
              .secondaryUserAgent("NewRelic-OpenTelemetry-Exporter/" + VersionFinder.readVersion())
              .auditLoggingEnabled(enableAuditLogging);

      if (uriOverride != null) {
        try {
          builder.endpoint(uriOverride.toURL());
        } catch (MalformedURLException e) {
          throw new IllegalArgumentException("Invalid URI for the metric API : " + uriOverride, e);
        }
      }
      telemetryClient =
          new TelemetryClient(MetricBatchSender.create(builder.build()), null, null, null);
      return new NewRelicMetricExporter(
          telemetryClient,
          commonAttributes,
          timeTracker,
          new MetricPointAdapter(timeTracker),
          AttributesSupport.SERVICE_INSTANCE_ID);
    }
  }
}
